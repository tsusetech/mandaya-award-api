generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model StatusProgress {
  id              Int      @id @default(autoincrement())
  entityType      String   // 'response_session' or 'review'
  entityId        Int      // ID of the ResponseSession or Review
  status          String   // The status value
  version         Int      // Incremental version (1 for latest, 2 for previous, etc.)
  previousStatus  String?  // The previous status before this change
  changedBy       Int?     // User ID who made the change
  changedAt       DateTime @default(now())
  metadata        Json?    // Additional metadata about the status change

  // Relations
  changedByUser   User?    @relation("StatusProgressChangedBy", fields: [changedBy], references: [id])

  @@unique([entityType, entityId, version])
  @@index([entityType, entityId])
  @@index([changedAt])
  @@index([status])
}

model User {
  id              Int               @id @default(autoincrement())
  email           String            @unique
  name            String?
  createdAt       DateTime          @default(now())
  password        String?
  updatedAt       DateTime          @updatedAt
  username        String            @unique
  deletedAt       DateTime?
  deletedBy       Int?
  userRoles       UserRole[]
  userGroups      UserGroup[]
  responseSessions ResponseSession[]
  reviews         Review[]          @relation("Reviewer")
  deletedByUser   User?             @relation("UserDeletedBy", fields: [deletedBy], references: [id])
  deletedUsers    User[]            @relation("UserDeletedBy")
  deletedRoles    Role[]            @relation("RoleDeletedBy")
  deletedQuestions Question[]        @relation("QuestionDeletedBy")
  deletedGroups   Group[]           @relation("GroupDeletedBy")
  deletedResponseSessions ResponseSession[] @relation("ResponseSessionDeletedBy")
  deletedCategories Category[]       @relation("CategoryDeletedBy")
  statusProgressChanges StatusProgress[] @relation("StatusProgressChangedBy")
}

model Role {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  deletedAt   DateTime?
  deletedBy   Int?
  userRoles   UserRole[]
  deletedByUser User?    @relation("RoleDeletedBy", fields: [deletedBy], references: [id])
}

model UserRole {
  id     Int  @id @default(autoincrement())
  userId Int
  roleId Int
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
}

model UserGroup {
  id      Int   @id @default(autoincrement())
  userId  Int
  groupId Int
  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
}

model Question {
  id                    Int                   @id @default(autoincrement())
  questionText          String
  description           String?               // Add this field
  inputType             String                // e.g. text-open, numeric, checkbox, multiple-choice
  isRequired            Boolean
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  deletedAt             DateTime?
  deletedBy             Int?

  groupQuestions        GroupQuestion[]
  responses             QuestionResponse[]
  reviewComments        ReviewComment[]
  juryScores            JuryScore[]
  currentInSessions     ResponseSession[]     @relation("CurrentQuestion")
  options               QuestionOption[]      // New relation to options
  deletedByUser         User?                 @relation("QuestionDeletedBy", fields: [deletedBy], references: [id])
}

model Group {
  id               Int               @id @default(autoincrement())
  groupName        String
  description      String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  deletedAt        DateTime?
  deletedBy        Int?

  groupQuestions   GroupQuestion[]
  userGroups       UserGroup[]
  responseSessions ResponseSession[]
  tahapGroupHierarchies TahapGroupHierarchy[]
  categoryGroups   CategoryGroup[]
  deletedByUser    User?             @relation("GroupDeletedBy", fields: [deletedBy], references: [id])
}

model GroupQuestion {
  id            Int      @id @default(autoincrement())
  groupId       Int
  questionId    Int
  orderNumber   Int
  sectionTitle  String?
  subsection    String?
  isGrouped     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  responses QuestionResponse[]
  questionTahapGroups QuestionTahapGroup[]

  @@index([groupId])
  @@index([questionId])
}

// New model for managing tahap group hierarchies
model TahapGroupHierarchy {
  id              Int      @id @default(autoincrement())
  groupId         Int
  tahapGroup      String   // e.g., "Tahap 1 Delta", "Tahap 2"
  groupIdentifier String   // e.g., "poverty_metrics", "p0_p2_average"
  calculationType String   // e.g., "delta", "average"
  description     String?
  parentGroupId   Int?     // Reference to parent tahap group (for hierarchical relationships)
  level           Int      @default(1) // Hierarchy level (1, 2, 3, etc.)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  group           Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  parentGroup     TahapGroupHierarchy? @relation("TahapGroupParent", fields: [parentGroupId], references: [id])
  childGroups     TahapGroupHierarchy[] @relation("TahapGroupParent")
  questionTahapGroups QuestionTahapGroup[] // Add this relation field

  @@unique([groupId, tahapGroup, groupIdentifier])
  @@index([groupId, level])
  @@index([parentGroupId])
}

// Junction table for many-to-many relationship between questions and tahap groups
model QuestionTahapGroup {
  id              Int      @id @default(autoincrement())
  groupQuestionId Int
  tahapGroupId    Int
  createdAt       DateTime @default(now())

  groupQuestion   GroupQuestion @relation(fields: [groupQuestionId], references: [id], onDelete: Cascade)
  tahapGroup      TahapGroupHierarchy @relation(fields: [tahapGroupId], references: [id], onDelete: Cascade)

  @@unique([groupQuestionId, tahapGroupId])
  @@index([groupQuestionId])
  @@index([tahapGroupId])
}

model ResponseSession {
  id                    Int      @id @default(autoincrement())
  userId                Int
  groupId               Int
  currentQuestionId     Int?
  progressPercentage    Int      @default(0)
  autoSaveEnabled       Boolean  @default(true)
  
  // Timestamps
  startedAt             DateTime @default(now())
  lastAutoSaveAt        DateTime?
  lastActivityAt        DateTime @updatedAt
  completedAt           DateTime?
  submittedAt           DateTime?
  reviewedAt            DateTime?
  deletedAt             DateTime?
  deletedBy             Int?
  
  // Relations
  user                  User @relation(fields: [userId], references: [id])
  group                 Group @relation(fields: [groupId], references: [id])
  currentQuestion       Question? @relation("CurrentQuestion", fields: [currentQuestionId], references: [id])
  responses             QuestionResponse[]
  review                Review?
  deletedByUser         User? @relation("ResponseSessionDeletedBy", fields: [deletedBy], references: [id])
  
  @@unique([userId, groupId])
  @@index([userId])
  @@index([lastActivityAt])
}

model QuestionResponse {
  id                    Int      @id @default(autoincrement())
  sessionId             Int
  questionId            Int
  groupQuestionId       Int
  
  // Response Values (based on question input_type)
  textValue             String?
  numericValue          Decimal?
  booleanValue          Boolean?
  arrayValue            Json?    // for multiple choice, file uploads, etc.
  
  // Auto-save State Management
  isDraft               Boolean  @default(true)
  isComplete            Boolean  @default(false)
  isSkipped             Boolean  @default(false)
  
  // Tracking
  autoSaveVersion       Int      @default(1)
  timeSpentSeconds      Int      @default(0)
  lastModifiedAt        DateTime @updatedAt
  firstAnsweredAt       DateTime?
  finalizedAt           DateTime?
  
  // Validation & Metadata
  validationErrors      Json?
  metadata              Json?
  
  // Relations
  session               ResponseSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question              Question @relation(fields: [questionId], references: [id])
  groupQuestion         GroupQuestion @relation(fields: [groupQuestionId], references: [id])
  
  @@unique([sessionId, questionId])
  @@index([sessionId, isDraft])
  @@index([lastModifiedAt])
}

model Review {
  id              Int           @id @default(autoincrement())
  sessionId       Int
  reviewerId      Int
  stage           String        // 'admin_validation', 'jury_scoring', 'jury_deliberation', 'final_decision'
  decision        String        // 'approve', 'reject', 'request_revision', 'pass_to_jury', 'needs_deliberation'
  overallComments String?
  totalScore      Decimal?      // Total jury score (0-100)
  deliberationNotes String?     // Notes from jury deliberation
  internalNotes   String?
  validationChecklist Json?     // Array of validation checklist items
  reviewedAt      DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  session         ResponseSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  reviewer        User @relation("Reviewer", fields: [reviewerId], references: [id])
  comments        ReviewComment[]
  juryScores      JuryScore[]

  @@unique([sessionId])
  @@index([reviewerId])
  @@index([stage])
  @@index([reviewedAt])
}

model ReviewComment {
  id          Int      @id @default(autoincrement())
  reviewId    Int
  questionId  Int
  comment     String
  isCritical  Boolean  @default(false)
  stage       String?  // Which review stage the comment was made
  createdAt   DateTime @default(now())

  // Relations
  review      Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  question    Question @relation(fields: [questionId], references: [id])

  @@index([reviewId])
  @@index([questionId])
  @@index([stage])
}

model JuryScore {
  id          Int      @id @default(autoincrement())
  reviewId    Int
  questionId  Int
  score       Decimal  // Score from 0-10
  comments    String?
  createdAt   DateTime @default(now())

  // Relations
  review      Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  question    Question @relation(fields: [questionId], references: [id])

  @@unique([reviewId, questionId])
  @@index([reviewId])
  @@index([questionId])
}

model QuestionOption {
  id              Int      @id @default(autoincrement())
  questionId      Int
  optionText      String
  optionValue     String   // The value that will be stored when this option is selected
  orderNumber     Int      // For maintaining the order of options
  isMultipleChoice Boolean  @default(false) // Indicates if this option is part of a multiple choice question
  isCheckBox      Boolean  @default(false)  // Indicates if this option should be rendered as a checkbox
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  question        Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
  @@index([orderNumber])
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?
  deletedBy   Int?

  // Relations
  categoryGroups CategoryGroup[]
  deletedByUser   User? @relation("CategoryDeletedBy", fields: [deletedBy], references: [id])

  @@index([deletedAt])
}

model CategoryGroup {
  id         Int      @id @default(autoincrement())
  categoryId Int
  groupId    Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([categoryId, groupId])
  @@index([categoryId])
  @@index([groupId])
}
